# The Pragmatic Programmer

## Notes & Strategies
I started reading this book on 1/20/2025.  So far, I'm through 6 of the 9 chapters.  Below, I will document the specific takeaways I've had from what I've read, and my strategies to apply these things in both my work routines and my career development projects.

### Chapter 1 - A Pragmatic Philosophy

This chapter is all about the responsibility of owning and directing your own future as a software engineer, and being responsible for the work that you produce.  My main takeaway from this chapter is to take pride in my work, and to build a professional portfolio that demonstrates my ability.  Specific things to remember:
- Don't Live with Broken Windows - a single instance of poor design or poor implementation, allowed, will encourage future transgressions, both by myself and others.  When expediency tempts me to make a shortcut or to "go back and fix it later", don't give in to this temptation.  That's a broken window.  When you see a freshly broken window by a colleague, call them out.
- Good Enough Software - there's no finish line.  Software that looks perfect today is out of date and incorrect tomorrow.  This isn't an invitation to engage in poor design, it's a reminder that software which is well designed and meets the user's requirements, is good enough and should be deployed.
- Knowledge Portfolio - it's kind of the inspiration for this entire site.  I want a continually maintained, demonstrable portfolio of skills, an updated (living) resume, and always a short term plan in progress for acquiring new skills.

### Chapter 2 - A Pragmatic Approach
- DRY (Don't Repeat Yourself) - I am well aware of this principle as the D in SOLID.  However, knowing by itself doesn't do anything.  More up-front design and more after-development review would help find the code duplication that occurs as the software gets written, which is a difficult time to recognize it.  Also, the code providing mock data for unit tests is a danger zone for duplicated code.
- Orthogonality - if changes in one thing don't necessitate changes in the other, then they are "orthogonal", and orthogoal code is maintainable code.  This is something to notice while making changes.  If making a simple change requires making parallel or sympathetic updates in several places, then fix it.
- Estimating - don't give them before you're ready, and don't apologize for not giving premature estimates.  And don't just guess.  Take the time to understand what's being asked and what the impact is before giving an estimate.  Tightly coupled systems that aren't orthogonal provide multipliers on estimates that you often neglect to include.

### Chapter 3 - The Basic Tools
- Shell Games - I really need to start thinking about using shell scripts to automate frequent jobs and using the shell script rather than the Windows GUI to do things.  This is probably best done by recognizing in the moment that I'm doing something repetetive or manual in the GUI that is likely automatable through a script.  Some of the things I do with the Print & Mail system are good candidates.
- Power Editing - I want to get better with VS Code rather than relying so much on Visual Studio.  Visual Studio pushes me towards back-end development in strictly .NET languages (C#).  I think VS Code is a better tool to work with front-end frameworks and other non-proprietary languages, but can also work with .NET code as well.
- Engineering Daybooks - I sort of already do this, and honestly it's a little like journaling, which I'm pretty good at.  But it's disjointed and disorganized.  It would be better if I had beginning-of-day and end-of-day rituals to formally start and end a daybook, and to review them in some kind of systematic way so I get feedback on my own notes.

### Chapter 4 - Pragmatic Paranoia

### Chapter 5 - Bend, or Break

### Chapter 6 - Concurrency

### Chapter 7 - While You Are Coding

### Chapter 8 - Before the Project

### Chapter 9 - Pragmatic Projects

---

[Back](README.md)