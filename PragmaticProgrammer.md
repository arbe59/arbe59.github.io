# The Pragmatic Programmer

## Notes & Strategies
I started reading this book on 1/20/2025.  So far, I'm through 6 of the 9 chapters.  Below, I will document the specific takeaways I've had from what I've read, and my strategies to apply these things in both my work routines and my career development projects.

### Chapter 1 - A Pragmatic Philosophy

This chapter is all about the responsibility of owning and directing your own future as a software engineer, and being responsible for the work that you produce.  My main takeaway from this chapter is to take pride in my work, and to build a professional portfolio that demonstrates my ability.  Specific things to remember:
- Don't Live with Broken Windows - a single instance of poor design or poor implementation, allowed, will encourage future transgressions, both by myself and others.  When expediency temps me to make a shortcut or to "go back and fix it later", don't give in to this temptation.  That's a broken window.  When you see a freshly broken window by a colleague, call them out.
- Good Enough Software - there's no finish line.  Software that looks perfect today is out of date and incorrect tomorrow.  This isn't an invitation to engage in poor design, it's a reminder that software which is well designed and meets the user's requirements, is good enough and should be deployed.
- Knowledge Portfolio - it's kind of the inspiration for this entire site.  I want a continually maintained, demonstrable portfolio of skills, an updated (living) resume, and always a short term plan in progress for acquiring new skills.

### Chapter 2 - A Pragmatic Approach
- DRY (Don't Repeat Yourself) - I am well aware of this principle as the D in SOLID.  However, knowing by itself doesn't do anything.  More up-front design and more after-development review would help find the code duplication that occurs as the software gets written, which is a difficult time to recognize it.  Also, the code providing mock data for unit tests is a danger zone for duplicated code.
- Orthogonality - if changes in one thing don't necessitate changes in the other, then they are "orthogonal", and orthogoal code is maintainable code.  This is something to notice while making changes.  If making a simple change requires making parallel or sympathetic updates in several places, then fix it.
- Estimating - don't give them before you're ready, and don't apologize for not giving premature estimates.  And don't just guess.  Take the time to understand what's being asked and what the impact is before giving an estimate.  Tightly coupled systems that aren't orthogonal provide multipliers on estimates that you often neglect to include.

### Chapter 3 - The Basic Tools

### Chapter 4 - Pragmatic Paranoia

### Chapter 5 - Bend, or Break

### Chapter 6 - Concurrency

### Chapter 7 - While You Are Coding

### Chapter 8 - Before the Project

### Chapter 9 - Pragmatic Projects

---

[Back](README.md)